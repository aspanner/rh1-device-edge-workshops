{% if wifi_network is defined and wifi_password is defined %}
%pre
nmcli dev wifi connect "{{ wifi_network }}" password "{{ wifi_password }}"
%end
{% endif %}
{% if wifi_network is not defined  %}
network --bootproto=dhcp --onboot=true
{% endif %}
keyboard --xlayouts='us'
lang en_US.UTF-8
timezone UTC
zerombr
clearpart --all --initlabel
autopart --type=plain --fstype=xfs --nohome
reboot
graphical
user --name=ansible --groups=wheel --password='{{ admin_password }}'
rootpw --plaintext --lock '{{ admin_password }}'
services --enabled=ostree-remount
ostreesetup --nogpg --url=http://ostree-repo.{{ ec2_name_prefix }}.{{ workshop_dns_zone }}/student-repos/student{{ student_number }}/repo --osname=rhel --ref=rhel/9/x86_64/edge

%post --log=/root/kickstart-post.log
set -x
{% if lab_wifi_network.ssid is defined and lab_wifi_network.password is defined %}
cat > /etc/systemd/system/connect-wifi.service <<EOF
[Unit]
Description=Connect to lab WiFi
After=network.target
ConditionPathExists=!/var/tmp/wifi-connected

[Service]
Type=oneshot
ExecStartPre=/usr/bin/nmcli radio wifi on
ExecStartPre=/usr/bin/sleep 5
ExecStartPre=/usr/bin/nmcli dev wifi rescan
ExecStartPre=/usr/bin/sleep 5
ExecStartPre=/usr/bin/nmcli dev wifi list
ExecStart=/usr/bin/nmcli dev wifi connect {{ lab_wifi_network.ssid }} password '{{ lab_wifi_network.password }}'
ExecStopPost=/usr/bin/touch /var/tmp/wifi-connected

[Install]
WantedBy=default.target
EOF
{% endif %}


cat > /var/tmp/aap-auto-registration.sh <<EOF
#!/bin/bash
conn_name=\$(nmcli con show | grep -v UUID | head -n 1 | awk '{print \$1}')
IP_ADDRESS=\$(nmcli conn show \$conn_name | grep ip_address | awk '{print \$4}')

#MAC_ADDRESS=\$(ip addr | grep wlp -A 1 | grep link | awk '{print \$2}' | sed 's/://g')
MAC_ADDRESS=\$(ip addr | grep \$conn_name -A 1 | grep link | awk '{print \$2}' | sed 's/://g')
STUDENT='{{ student_number }}'

JSON="{\
\"ip_address\": \"\$IP_ADDRESS\", \
\"student\": \"\$STUDENT\", \
\"mac_address\": \"\$MAC_ADDRESS\" \
}"

/usr/bin/curl -H 'Content-Type: application/json' --data "\$JSON" https://eda.{{ ec2_name_prefix }}.{{ workshop_dns_zone }}/endpoint
EOF

chmod +x  /var/tmp/aap-auto-registration.sh


cat > /etc/systemd/system/aap-auto-registration.service <<EOF
[Unit]
Description=Register to Ansible Automation Platform
After=network.target
After=connect-wifi.service
ConditionPathExists=!/var/tmp/aap-registered

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do /var/tmp/aap-auto-registration.sh && /usr/bin/touch /var/tmp/aap-registered && break; done'

[Install]
WantedBy=default.target
EOF

systemctl daemon-reload
systemctl enable connect-wifi.service
systemctl enable aap-auto-registration.service




### python3-inotify

## **** REMEMBER TO HAVE PYTHON3-INOTIFY INSTALLED


pip3 install inotify requests

# Create the Python script to watch /etc and send a webhook with JSON data
cat <<EOF > /usr/local/bin/watch_etc.py
#!/usr/bin/env python3

import inotify.adapters
import requests
import os

# Define the directory to monitor
DIRECTORY = '/etc'

# Define your webhook URL
WEBHOOK_URL = "https://eda.training.sandbox1339.opentlc.com/endpoint"

# Function to send a webhook with JSON data
def send_webhook(path, filename, event_type, student, inventory):
    json_data = {
        "student": student,
        "inventory": inventory,
        "path": path,
        "file_changed": filename,
        "event_type": event_type
    }

    headers = {'Content-Type': 'application/json'}
    response = requests.post(WEBHOOK_URL, json=json_data, headers=headers)
    if response.status_code == 200:
        print(f'Webhook sent: {filename}')

# Check if the "/root/inotify-wait" file exists
def inotify_wait_exists():
    return os.path.exists('/root/inotify-wait')

try:
    conn_name = subprocess.check_output("nmcli con show | grep -v UUID | head -n 1 | awk '{print $1}'", shell=True)
    conn_name = conn_name.decode("utf-8").strip()
except subprocess.CalledProcessError as e:
    print(f"Error running the first shell command: {e}")
    conn_name = None

# Check if the connection name was retrieved successfully
if conn_name:
    # Run the second shell command to get the MAC address
    try:
        MAC_ADDRESS = subprocess.check_output(f"ip addr | grep {conn_name} -A 1 | grep link | awk '{print $2}' | sed 's/://g'", shell=True)
        MAC_ADDRESS = MAC_ADDRESS.decode("utf-8").strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running the second shell command: {e}")
        MAC_ADDRESS = None

# Check if both variables are available
if conn_name and MAC_ADDRESS:
    inventory = f'edge-{MAC_ADDRESS}'

# Initialize the inotify watcher
i = inotify.adapters.InotifyTree(DIRECTORY)

for event in i.event_gen(yield_nones=False):
      (_, type_names, path, filename) = event
      print("                                PATH=[{}] FILENAME=[{}] EVENT_TYPES={}".format( path, filename, type_names))
      # Check the file extension and skip unwanted extensions
      _, file_extension = os.path.splitext(filename)

      if file_extension not in ('.swp', '.ddf'):
        print("variable: {}".format(type_names))
        if any(event_type in ['IN_CREATE', 'IN_MODIFY', 'IN_DELETE', 'IN_MOVE'] for event_type in type_names):
            # Check if the "/root/inotify-wait" file exists
            if not inotify_wait_exists():
                # Send a webhook notification with JSON data
                print("PATH=[{}] FILENAME=[{}] EVENT_TYPES={}".format(path, filename, type_names))
                send_webhook(path, filename, type_names, {{ student_number }}, inventory )
                # Create the "/root/inotify-wait" file
                open('/root/inotify-wait', 'w').close()

i.remove_watch(DIRECTORY)
EOF

# Make the script executable
chmod +x /usr/local/bin/watch_etc.py

# Define the webhook URL (replace with your actual URL)
WEBHOOK_URL="https://eda.{{ ec2_name_prefix }}.{{ workshop_dns_zone }}/endpoint"

# Create a systemd service unit to run the Python script
cat <<EOF > /etc/systemd/system/watch-etc.service
[Unit]
Description=Watch /etc for file changes and send a webhook

[Service]
ExecStart=/usr/local/bin/watch_etc.py
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Reload systemd to read the new unit file
systemctl daemon-reload

# Enable and start the service
systemctl enable watch-etc.service
systemctl start watch-etc.service



######## Greenboot

sudo cat << 'EOF' > /etc/greenboot/check/required.d/01-check-packages.sh
#!/bin/bash

# List of required packages
required_packages=("python3-pip" "python3-inotify" "git")

# Check if each package is installed
for package in "${required_packages[@]}"; do
    if ! rpm -q "$package" &>/dev/null; then
        echo "Error: $package is not installed."
        exit 1
    fi
done

echo "All required packages are installed."
EOF

chmod +x /etc/greenboot/check/required.d/01-check-packages.sh

%end
